<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><head><title>Contrôle hors-classement École polytechnique Informatique -- Cours INF 431</title>



<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="GENERATOR" content="hevea 1.06"></head><body bgcolor="white" text="black">
<!--HEVEA command line is: hevea sem.hva hcbis.tex -->
<!--HTMLHEAD-->
<!--ENDHTML-->
<!--PREFIX <ARG ></ARG>-->
<!--CUT DEF section 1 -->

<div align="center"><table cellpadding="10">
<tbody><tr><td bgcolor="#cccc00"><div align="center">
<font size="8"><b>
 Contrôle hors-classement<br>
École polytechnique<br>
<font color="purple">Informatique -- Cours INF 431</font></b></font><br>
<br>
<font size="5"><b>
 Guillaume Hanrot et Jean-Jacques Lévy</b></font><br>
<font size="5"><b>
 27 avril 2004</b></font></div></td>
</tr></tbody></table></div><br>
<br>
<br>
<br>
<br>
<br>
On se propose de résoudre le problème de l'affectation de <i>k</i> tâches à
<i>n</i> employés (<i>k</i> &gt;0, <i>n</i> &gt;0). Un employé se voit attribuer une tâche
prise parmi une liste de tâches pour lesquelles il est compétent. On
cherche à trouver une affectation optimale qui maximise le nombre de
tâches qui peuvent être effectuées simultanément.<br>
<br>
Ce problème sera modélisé en utilisant un graphe. La première partie
définit un certain nombre de classes utiles dans la modélisation et le
traitement du problème; la seconde partie calcule l'affectation en
utilisant le graphe construit.<br>
<br>
<!--TOC section Modélisation du problème-->
<table cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#e5e52d"><div align="center"><table>
<tbody><tr><td><a name="htoc1"><b><font size="5">1</font></b></a></td>
<td align="center" width="100%"><b><font size="5">Modélisation du problème</font></b></td>
</tr></tbody></table></div></td>
</tr></tbody></table><!--SEC END -->
<br>
Les employés ont chacun un nom représenté par une chaîne de
caractères; les tâches sont repérées par leurs identifiants qui sont
des entiers naturels tous différents. On considère un graphe avec
<i>n</i>+<i>k</i>+2 sommets; chaque sommet est soit un employé, soit une tâche,
soit un des deux sommets spéciaux <tt>Debut</tt> et <tt>Fin</tt>. Il y a un
arc allant d'un employé vers une tâche pour laquelle cet employé est
compétent. Il y a des arcs entre le sommet <tt>Debut</tt> et tous les
employés; il y a également des arcs entre toutes les tâches et le
sommet <tt>Fin</tt> (cf.&nbsp;la figure&nbsp;<a href="#fig:graphe">1</a>).
<blockquote><div align="center"><hr size="2" width="80%"></div>

<div align="center">
<img src="algorithme%20pb%20affectation%20graphe_fichiers/hcbis001.gif"></div><br>
<div align="center">Figure 1: Graphe des employés et des tâches</div><br>

<a name="fig:graphe"></a>
<div align="center"><hr size="2" width="80%"></div></blockquote>
Dans l'exemple de la figure 1, on a <i>n</i>=<i>k</i>=3; le graphe a 3 sommets ``employés`` avec pour nom <code><tt>"Pierre"</tt></code>, <code><tt>"Paul"</tt></code>,
<code><tt>"Jean"</tt></code>, et 3 sommets ``tâches`` <i>t</i><sub><font size="2">1</font></sub>, <i>t</i><sub><font size="2">2</font></sub>, <i>t</i><sub><font size="2">3</font></sub>. En
outre, <code><tt>"Pierre"</tt></code> est compétent pour les tâches <i>t</i><sub><font size="2">2</font></sub> et
<i>t</i><sub><font size="2">3</font></sub>; <code><tt>"Paul"</tt></code> est compétent pour <i>t</i><sub><font size="2">1</font></sub>; <code><tt>"Jean"</tt></code>
est compétent pour <i>t</i><sub><font size="2">3</font></sub>. Une affectation optimale 
affecte <code><tt>"Pierre"</tt></code> à <i>t</i><sub><font size="2">2</font></sub>, <code><tt>"Paul"</tt></code> à <i>t</i><sub><font size="2">1</font></sub> et
<code><tt>"Jean"</tt></code> à <i>t</i><sub><font size="2">3</font></sub>, permettant d'effectuer 3 tâches
en parallèle, alors que l'affectation de <code><tt>"Pierre"</tt></code> à <i>t</i><sub><font size="2">3</font></sub>
empêche <code><tt>"Jean"</tt></code> de travailler et ne laisse que
la possibilité à <code><tt>"Paul"</tt></code> de faire <i>t</i><sub><font size="2">1</font></sub>.<br>
<br>
<br>
<br>
<br>
<br>
Les quatres sortes de sommets sont représentées par un type disjonctif
à partir d'une classe abstraite <code>Sommet</code>, de telle manière
que chaque sommet a un entier naturel distinct comme numéro (champ
<code>num</code>), une liste d'entiers qui désigne les numéros de ses
successeurs dans le graphe (champ <code>succ</code>). La classe
<code>Employe</code> a les champs supplémentaires <code>nom</code> pour
le nom de l'employé et <code>aFaire</code> indiquant la tâche
finalement affectée à l'employé; la classe <code>Tache</code> a un
champ entier <code>id</code> donnant l'identifiant <i>i</i> de la tâche
<i>t</i><sub><font size="2"><i>i</i></font></sub>; les classes <code>Debut</code> et <code>Fin</code> n'ont pas de
champs supplémentaires. On utilisera également la classe suivante pour
manipuler les listes d'entiers:<br>
<div align="left"><tt> </tt><tt>
</tt><tt>&nbsp;&nbsp;int</tt><tt>&nbsp;val;&nbsp;Liste&nbsp;suivant;</tt><tt><br>
</tt><tt>&nbsp;&nbsp;Liste&nbsp;(int</tt><tt>&nbsp;x,&nbsp;Liste&nbsp;ls)&nbsp;{&nbsp;val&nbsp;=&nbsp;x;&nbsp;suivant&nbsp;=&nbsp;ls;&nbsp;}</tt><tt><br>
</tt><tt><br>
</tt><tt>&nbsp;&nbsp;static</tt><tt>&nbsp;Liste&nbsp;enlever&nbsp;(int</tt><tt>&nbsp;x,&nbsp;Liste&nbsp;ls)&nbsp;{</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;if</tt><tt>&nbsp;(ls&nbsp;==&nbsp;null</tt><tt>)&nbsp;return</tt><tt>&nbsp;null</tt><tt>;</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;else</tt><tt>&nbsp;if</tt><tt>&nbsp;(ls.val&nbsp;==&nbsp;x)&nbsp;return</tt><tt>&nbsp;ls.suivant;</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;else</tt><tt>&nbsp;return</tt><tt>&nbsp;new</tt><tt>&nbsp;Liste&nbsp;(ls.val,&nbsp;enlever&nbsp;(x,&nbsp;ls.suivant));</tt><tt><br>
</tt><tt>}&nbsp;}</tt></div><br>
<br>
<b>Question
1</b>&nbsp;Définir les classes <code>Sommet</code>, <code>Employe</code>,
<code>Tache</code>, <code>Debut</code>, <code>Fin</code> en donnant un 
constructeur dans chaque classe.<br>
<br>
<br>
<b>Question
2</b>&nbsp;Écrire une méthode <code>estEmploye</code>, sans argument, 
qui renvoie la valeur <code><tt>true</tt></code> si le sommet est un employé, et 
<code><tt>false</tt></code> dans les autres cas.<br>
<br>
<br>
<b>Question
3</b>&nbsp;Écrire une méthode <code>toString</code> permettant
d'afficher tout sommet. Pour un employé, on écrira son nom et la tâche
à effectuer si elle existe; pour une tâche, son identifiant précédé de la
lettre ``t''; pour les sommets spéciaux de début et de fin, les chaînes
de caractères <code><tt>"début"</tt></code> et <code><tt>"fin"</tt></code>.<br>
<br>
<br>
<br>
Le graphe est représenté par un tableau <code>sommet</code> de <i>n</i>+<i>k</i>+2
sommets. Ainsi le graphe de l'exemple précédent est représenté par le
tableau de 8 éléments comme indiqué sur la figure&nbsp;<a href="#fig:grapheimp">2</a>.
<blockquote><div align="center"><hr size="2" width="80%"></div>

<div align="center">
<img src="algorithme%20pb%20affectation%20graphe_fichiers/hcbis002.gif"></div><br>
<div align="center">Figure 2: Implémentation du graphe des employés et des tâches: les
 champs <code>aFaire</code> n'ont pas encore de valeur; les champs
 <code>succ</code>, non complétés sur la figure, indiquent les
 extrémités des arcs issus de chaque sommet. Ainsi
 <code>sommet[0].succ</code> vaut la liste <font face="symbol">á</font> 4, 5<font face="symbol">ñ</font>,
 <code>sommet[1].succ</code> vaut la liste <font face="symbol">á</font> 3<font face="symbol">ñ</font>,
 <code>sommet[2].succ</code> vaut la liste <font face="symbol">á</font> 5<font face="symbol">ñ</font>,
 <code>sommet[3].succ</code> vaut la liste <font face="symbol">á</font> 7<font face="symbol">ñ</font>, 
 <code>sommet[4].succ</code> vaut la liste <font face="symbol">á</font> 7<font face="symbol">ñ</font>, 
 <code>sommet[5].succ</code> vaut la liste <font face="symbol">á</font> 7<font face="symbol">ñ</font>, 
 <code>sommet[6].succ</code> vaut la liste <font face="symbol">á</font> 0,1,2<font face="symbol">ñ</font>, 
 <code>sommet[7].succ</code> vaut <code><tt>null</tt></code>.</div><br>

<a name="fig:grapheimp"></a>
<div align="center"><hr size="2" width="80%"></div></blockquote>
<br>
<b>Question
4</b>&nbsp;Définir la classe <code>Graphe</code> avec un constructeur
prenant en argument son nombre de sommets.<br>
<br>
<br>
<b>Question
5</b>&nbsp;Écrire la méthode <code>ajouterSommet</code>(<i>x</i>,<i>s</i>) qui
ajoute le sommet <i>s</i> dans le graphe en lui donnant le numéro <i>x</i>.<br>
<br>
<br>
<b>Question
6</b>&nbsp;Écrire les méthodes <code>ajouterArc</code>(<i>x</i>,<i>y</i>) et 
<code>enleverArc</code>(<i>x</i>,<i>y</i>), qui ajoute (ou supprime) un arc
entre le sommet de numéro <i>x</i> et le sommet de numéro <i>y</i>.<br>
<br>
<br>
<br>
<br>
<br>
<!--TOC section Résolution du problème-->
<table cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#e5e52d"><div align="center"><table>
<tbody><tr><td><a name="htoc2"><b><font size="5">2</font></b></a></td>
<td align="center" width="100%"><b><font size="5">Résolution du problème</font></b></td>
</tr></tbody></table></div></td>
</tr></tbody></table><!--SEC END -->
<br>
<br>
<br>
<br>
<br>
On utilise un graphe des employés et des tâches comme décrit
précédemment avec les deux sommets distingués, dorénavant appelés <i>d</i>
pour l'objet de la classe <code>Debut</code> et <i>f</i> pour l'objet de la
classe <code>Fin</code>.<br>
<br>
L'algorithme pour construire l'affectation optimale fonctionne par
itération du calcul suivant: à chaque itération, on cherche un chemin
quelconque reliant <i>d</i> à <i>f</i> dans le graphe. Si on trouve un tel
chemin, on modifie le graphe en retournant les arcs qui composent ce
chemin dans le graphe et on passe à l'itération suivante. Si un tel
chemin n'existe pas, l'algorithme est terminé. Sur la
figure&nbsp;<a href="#fig:ff">3</a>, on voit les différentes étapes de cet algorithme,
inspiré d'un algorithme plus général sur les flots dans les graphes
par Ford et Fulkerson.<br>
<br>
L'affectation optimale est donnée en consultant les arcs reliant un
sommet ``tâche`` à un sommet ``employé`` pour tous les sommets
``employés`` accessibles depuis le sommet <i>f</i> à la fin de
l'algorithme. Sur l'exemple de la figure&nbsp;<a href="#fig:ff">3</a>(f), les trois
sommets <i>t</i><sub><font size="2">1</font></sub>, <i>t</i><sub><font size="2">2</font></sub> et <i>t</i><sub><font size="2">3</font></sub> sont accessibles depuis le sommet de fin
<i>f</i> ; ils n'ont alors qu'un seul successeur dans le graphe (on peut
démontrer que c'est toujours le cas). Ce sommet est par ailleurs
forcément un ``employé`` et une affectation optimale donne donc
<code>Paul</code> pour <i>t</i><sub><font size="2">1</font></sub>, <code>Pierre</code> pour <i>t</i><sub><font size="2">2</font></sub>,
<code>Jean</code> pour <i>t</i><sub><font size="2">3</font></sub>.<br>
<br>
On représente un chemin dans le graphe par la liste des numéros de
tous les sommets qui le composent (sommets de départ et d'arrivée
compris) dans l'ordre où ils sont rencontrés sur le chemin.<br>
<br>
<br>
<b>Question
7</b>&nbsp;Écrire la méthode <code>chemin</code>(<i>x</i>,<i>y</i>) qui renvoie
comme résultat un chemin allant du sommet de numéro <i>x</i> au sommet de
numéro <i>y</i> dans le graphe. Si le chemin n'existe pas, cette méthode
renvoie <code><tt>null</tt></code>. Quelle est la complexité en temps de cette
méthode ?<br>
<br>
<br>
<b>Question
8</b>&nbsp;Écrire la méthode <code>retournerLesArcsDe</code>(<i><font color="red"><i>l</i></font>&nbsp;</i>) qui
modifie le graphe en retournant les arcs rencontrés sur le chemin
<i><font color="red"><i>l</i></font>&nbsp;</i>.<br>
<br>
<br>
<b>Question
9</b>&nbsp;Écrire la méthode <code>calculerResultat</code>(<i>f</i>) qui
prend en argument le sommet <i>f</i> de fin, et qui affecte, en fin de
l'algorithme, les champs <code>aFaire</code> des employés par la tâche
qu'ils devront faire dans l'affectation optimale trouvée par l'algorithme.<br>
<br>
<br>
<b>Question
10</b>&nbsp;Écrire la méthode <code>fordFulkerson</code>(<i>d</i>,<i>f</i>) qui
trouve une affectation optimale à partir des deux sommets <i>d</i> et <i>f</i> de
début et de fin. La méthode ne renvoie pas de résultat, mais modifie
les champs <code>aFaire</code> des employés contenus dans le graphe.
Quelle est la complexité en temps de cette méthode ? <br>
<br>
<br>
<b>Question
11</b>&nbsp;Écrire la méthode <code>afficherResultat</code>() qui
imprime pour tous les employés leur tâche affectée.
<blockquote><div align="center"><hr size="2" width="80%"></div>

<div align="center">
<img src="algorithme%20pb%20affectation%20graphe_fichiers/hcbis003.gif"></div><br>
<div align="center">Figure 3: Algorithme d'affectation: les 6 étapes successives; les
 chemins trouvés entre les sommets Début et Fin sont en traits
 discontinus; ses arcs sont retournés à l'étape suivante (remarquons
 que le graphe devient cyclique à l'étape (<i>b</i>)). A la fin de
 l'algorithme, sur la figure (f), les 3 tâches <i>t</i><sub><font size="2">1</font></sub>, <i>t</i><sub><font size="2">2</font></sub> et <i>t</i><sub><font size="2">3</font></sub>
 sont des successeurs de Fin dans le graphe; l'affectation optimale
 est donnée par les arcs reliant <i>t</i><sub><font size="2">1</font></sub> à Paul, <i>t</i><sub><font size="2">2</font></sub> à Pierre et
 <i>t</i><sub><font size="2">3</font></sub> à Jean.</div><br>

<a name="fig:ff"></a>
<div align="center"><hr size="2" width="80%"></div></blockquote>
<!--TOC section Corrigé-->
<table cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td bgcolor="#e5e52d"><div align="center"><table>
<tbody><tr><td><a name="htoc3"><b><font size="5">3</font></b></a></td>
<td align="center" width="100%"><b><font size="5">Corrigé</font></b></td>
</tr></tbody></table></div></td>
</tr></tbody></table><!--SEC END -->

<br>
<br>
<b>Question
1</b>&nbsp;<div align="left"><tt> </tt><tt>
</tt><tt>&nbsp;&nbsp;int</tt><tt>&nbsp;num;</tt><tt><br>
</tt><tt>&nbsp;&nbsp;Liste&nbsp;succ;</tt><tt><br>
</tt><tt>}</tt><tt><br>
</tt><tt><br>
</tt><tt>class</tt><tt>&nbsp;Employe&nbsp;extends</tt><tt>&nbsp;Sommet&nbsp;{</tt><tt><br>
</tt><tt>&nbsp;&nbsp;String&nbsp;nom;</tt><tt><br>
</tt><tt>&nbsp;&nbsp;Tache&nbsp;aFaire;</tt><tt><br>
</tt><tt>}</tt><tt><br>
</tt><tt><br>
</tt><tt>class</tt><tt>&nbsp;Tache&nbsp;extends</tt><tt>&nbsp;Sommet&nbsp;{</tt><tt><br>
</tt><tt>&nbsp;&nbsp;int</tt><tt>&nbsp;id;</tt><tt><br>
</tt><tt>&nbsp;&nbsp;Tache&nbsp;(int</tt><tt>&nbsp;x)&nbsp;{&nbsp;id&nbsp;=&nbsp;x;&nbsp;}</tt><tt><br>
</tt><tt>}</tt><tt><br>
</tt><tt><br>
</tt><tt>class</tt><tt>&nbsp;Debut&nbsp;extends</tt><tt>&nbsp;Sommet&nbsp;{&nbsp;}</tt><tt><br>
</tt><tt>class</tt><tt>&nbsp;Fin&nbsp;extends</tt><tt>&nbsp;Sommet&nbsp;{&nbsp;}</tt></div><br>
<br>
<b>Question
2</b>&nbsp;<div align="left"><tt> </tt><tt>
</tt><tt>&nbsp;&nbsp;abstract</tt><tt>&nbsp;boolean</tt><tt>&nbsp;estEmploye();</tt><tt><br>
</tt><tt>}</tt><tt><br>
</tt><tt><br>
</tt><tt>class</tt><tt>&nbsp;Employe&nbsp;extends</tt><tt>&nbsp;Sommet&nbsp;{&nbsp;...</tt><tt><br>
</tt><tt>&nbsp;&nbsp;boolean</tt><tt>&nbsp;estEmploye()&nbsp;{&nbsp;return</tt><tt>&nbsp;true</tt><tt>;&nbsp;}</tt><tt><br>
</tt><tt>}</tt><tt><br>
</tt><tt><br>
</tt><tt>class</tt><tt>&nbsp;Tache&nbsp;extends</tt><tt>&nbsp;Sommet&nbsp;{&nbsp;...</tt><tt><br>
</tt><tt>&nbsp;&nbsp;boolean</tt><tt>&nbsp;estEmploye()&nbsp;{&nbsp;return</tt><tt>&nbsp;false</tt><tt>;&nbsp;}</tt><tt><br>
</tt><tt>}</tt><tt><br>
</tt><tt><br>
</tt><tt>class</tt><tt>&nbsp;Debut&nbsp;extends</tt><tt>&nbsp;Sommet&nbsp;{</tt><tt><br>
</tt><tt>&nbsp;&nbsp;boolean</tt><tt>&nbsp;estEmploye()&nbsp;{&nbsp;return</tt><tt>&nbsp;false</tt><tt>;&nbsp;}</tt><tt><br>
</tt><tt>}</tt><tt><br>
</tt><tt><br>
</tt><tt>class</tt><tt>&nbsp;Fin&nbsp;extends</tt><tt>&nbsp;Sommet&nbsp;{</tt><tt><br>
</tt><tt>&nbsp;&nbsp;boolean</tt><tt>&nbsp;estEmploye()&nbsp;{&nbsp;return</tt><tt>&nbsp;false</tt><tt>;&nbsp;}</tt><tt><br>
</tt><tt>}</tt></div><br>
<br>
<b>Question
3</b>&nbsp;<div align="left"><tt> </tt><tt>
</tt><tt>&nbsp;&nbsp;public</tt><tt>&nbsp;String&nbsp;toString()&nbsp;{</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;if</tt><tt>&nbsp;(aFaire&nbsp;==&nbsp;null</tt><tt>)&nbsp;return</tt><tt>&nbsp;nom;</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;else</tt><tt>&nbsp;return</tt><tt>&nbsp;nom&nbsp;+&nbsp;"&nbsp;"</tt><tt>&nbsp;+&nbsp;aFaire;</tt><tt><br>
</tt><tt>&nbsp;&nbsp;}</tt><tt><br>
</tt><tt>}</tt><tt><br>
</tt><tt><br>
</tt><tt>class</tt><tt>&nbsp;Tache&nbsp;extends</tt><tt>&nbsp;Sommet&nbsp;{&nbsp;...</tt><tt><br>
</tt><tt>&nbsp;&nbsp;public</tt><tt>&nbsp;String&nbsp;toString()&nbsp;{&nbsp;return</tt><tt>&nbsp;"t"</tt><tt>&nbsp;+&nbsp;id;&nbsp;}</tt><tt><br>
</tt><tt>}</tt><tt><br>
</tt><tt><br>
</tt><tt>class</tt><tt>&nbsp;Debut&nbsp;extends</tt><tt>&nbsp;Sommet&nbsp;{&nbsp;...</tt><tt><br>
</tt><tt>&nbsp;&nbsp;public</tt><tt>&nbsp;String&nbsp;toString()&nbsp;{&nbsp;return</tt><tt>&nbsp;"Debut"</tt><tt>;&nbsp;}</tt><tt><br>
</tt><tt>}</tt><tt><br>
</tt><tt><br>
</tt><tt>class</tt><tt>&nbsp;Fin&nbsp;extends</tt><tt>&nbsp;Sommet&nbsp;{&nbsp;&nbsp;...</tt><tt><br>
</tt><tt>&nbsp;&nbsp;public</tt><tt>&nbsp;String&nbsp;toString()&nbsp;{&nbsp;return</tt><tt>&nbsp;"Fin"</tt><tt>;&nbsp;}</tt><tt><br>
</tt><tt>}</tt></div><br>
<br>
<b>Question
4</b>&nbsp;<div align="left"><tt> </tt><tt>
</tt><tt>&nbsp;&nbsp;Sommet[&nbsp;]&nbsp;sommet;</tt><tt><br>
</tt><tt>&nbsp;&nbsp;Graphe&nbsp;(int</tt><tt>&nbsp;n)&nbsp;{&nbsp;sommet&nbsp;=&nbsp;new</tt><tt>&nbsp;Sommet[n];&nbsp;}</tt><tt><br>
</tt><tt>}</tt></div><br>
<br>
<b>Question
5</b>&nbsp;<div align="left"><tt> </tt></div><br>
<br>
<b>Question
6</b>&nbsp;<div align="left"><tt> </tt><tt>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;sommet[x].succ&nbsp;=&nbsp;new</tt><tt>&nbsp;Liste&nbsp;(y,&nbsp;sommet[x].succ);</tt><tt><br>
</tt><tt>&nbsp;&nbsp;}</tt><tt><br>
</tt><tt><br>
</tt><tt>&nbsp;&nbsp;void</tt><tt>&nbsp;supprimerArc&nbsp;(int</tt><tt>&nbsp;x,&nbsp;int</tt><tt>&nbsp;y)&nbsp;{</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;sommet[x].succ&nbsp;=&nbsp;Liste.enlever&nbsp;(y,&nbsp;sommet[x].succ);</tt><tt><br>
</tt><tt>&nbsp;&nbsp;}</tt></div><br>
<br>
<b>Question
7</b>&nbsp;La fonction suivante prend un temps <i>O</i>(<i>n</i>+<i>k</i>).
<div align="left"><tt> </tt><tt>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;boolean</tt><tt>[&nbsp;]&nbsp;dejaVu&nbsp;=&nbsp;new</tt><tt>&nbsp;boolean</tt><tt>[sommet.length];</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;return</tt><tt>&nbsp;dfs&nbsp;(x.num,&nbsp;y.num,&nbsp;dejaVu);</tt><tt><br>
</tt><tt>&nbsp;&nbsp;}</tt><tt><br>
</tt><tt><br>
</tt><tt>&nbsp;&nbsp;Liste&nbsp;dfs&nbsp;(int</tt><tt>&nbsp;d,&nbsp;int</tt><tt>&nbsp;f,&nbsp;boolean</tt><tt>[&nbsp;]&nbsp;dejaVu)&nbsp;{</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;dejaVu[d]&nbsp;=&nbsp;true</tt><tt>;</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;if</tt><tt>&nbsp;(d&nbsp;==&nbsp;f)</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return</tt><tt>&nbsp;new</tt><tt>&nbsp;Liste&nbsp;(d,&nbsp;null</tt><tt>);</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;for</tt><tt>&nbsp;(Liste&nbsp;ls&nbsp;=&nbsp;sommet[d].succ;&nbsp;ls&nbsp;!=&nbsp;null</tt><tt>;&nbsp;ls&nbsp;=&nbsp;ls.suivant)&nbsp;{</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int</tt><tt>&nbsp;x&nbsp;=&nbsp;ls.val;</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if</tt><tt>&nbsp;(&nbsp;!dejaVu[x]&nbsp;)&nbsp;{</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Liste&nbsp;r&nbsp;=&nbsp;dfs&nbsp;(x,&nbsp;f,&nbsp;dejaVu);</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if</tt><tt>&nbsp;(r&nbsp;!=&nbsp;null</tt><tt>)</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return</tt><tt>&nbsp;new</tt><tt>&nbsp;Liste&nbsp;(d,&nbsp;r);</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;}</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;return</tt><tt>&nbsp;null</tt><tt>;</tt><tt><br>
</tt><tt>&nbsp;&nbsp;}</tt></div><br>
<br>
<b>Question
8</b>&nbsp;<div align="left"><tt> </tt><tt>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;for</tt><tt>&nbsp;(int</tt><tt>&nbsp;x&nbsp;=&nbsp;-1;&nbsp;ls&nbsp;!=&nbsp;null</tt><tt>;&nbsp;ls&nbsp;=&nbsp;ls.suivant)&nbsp;{</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int</tt><tt>&nbsp;y&nbsp;=&nbsp;ls.val;</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if</tt><tt>&nbsp;(x&nbsp;&gt;=&nbsp;0)&nbsp;{</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;supprimerArc&nbsp;(x,&nbsp;y);</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ajouterArc&nbsp;(y,&nbsp;x);</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;y;</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;}</tt><tt><br>
</tt><tt>&nbsp;&nbsp;}</tt></div><br>
<br>
<b>Question
9</b>&nbsp;<div align="left"><tt> </tt><tt>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;for</tt><tt>&nbsp;(Liste&nbsp;ls&nbsp;=&nbsp;f.succ&nbsp;;&nbsp;ls&nbsp;!=&nbsp;null</tt><tt>;&nbsp;ls&nbsp;=&nbsp;ls.suivant)&nbsp;{</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int</tt><tt>&nbsp;x&nbsp;=&nbsp;ls.val;</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int</tt><tt>&nbsp;y&nbsp;=&nbsp;sommet[x].succ.val;</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sommet[y].aFaire&nbsp;=&nbsp;(Tache)&nbsp;sommet[x];</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;}</tt><tt><br>
</tt><tt>&nbsp;&nbsp;}</tt></div><br>
<br>
<b>Question
10</b>&nbsp;<div align="left"><tt> </tt><tt>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;Liste&nbsp;ls;</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;while</tt><tt>&nbsp;((ls&nbsp;=&nbsp;chemin(d,&nbsp;f))&nbsp;!=&nbsp;null</tt><tt>)</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retournerLesArcsDe&nbsp;(ls);</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;calculerResultat&nbsp;(f);</tt><tt><br>
</tt><tt>&nbsp;&nbsp;}</tt></div><br>
À chaque étape, on trouve un chemin de <i>d</i> vers <i>f</i> ; ce chemin
passe une seule fois par <i>f</i>, donc contient un arc d'extrémité <i>f</i> et
aucun arc d'origine <i>f</i>. Par suite, à chaque execution de
<code>chemin</code> puis <code>retournerLesArcsDe</code>, le nombre
d'arcs d'extrémité <i>f</i> décroît d'une unité. Comme initialement le
nombre d'arcs d'extrémité <i>f</i> vaut <i>k</i>, en au plus <i>k</i> étapes, on peut
garantir qu'il n'y a plus d'arcs d'extrémité <i>f</i>, donc a fortiori plus
de chemin de <i>d</i> à <i>f</i>. On effectue donc <i>O</i>(<i>k</i>) appels à
<code>chemin</code>, qui est de complexité <i>O</i>(<i>n</i>+<i>k</i>), et <i>O</i>(<i>k</i>) appels à
<code>retournerLesArcsDe</code>. Cette dernière méthode parcourt les
listes de successeurs des sommets du chemin. Dans ces parcours, un arc
est rencontré au plus une fois, donc la complexité est dominée par le
nombre d'arcs du graphe, soit <i>O</i>(<i>nk</i>). Enfin,
<code>calculerResultat</code> a un coût proportionnel au nombre
d'arcs issus de fin, soit au plus <i>O</i>(<i>k</i>). La complexité totale est
donc <i>O</i>(<i>nk</i><sup><font size="2">2</font></sup>) (le terme principal est celui provenant de
<code>retournerLesArcsDe</code>), que l'on peut ramener à <i>O</i>(<i>nk</i> min(<i>n</i>,
<i>k</i>)) en remarquant que le même argument de décroissance s'applique
aux arcs sortant de <i>d</i>.<br>
<br>
<br>
<b>Question
11</b>&nbsp;<div align="left"><tt> </tt><tt>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;for</tt><tt>&nbsp;(int</tt><tt>&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;sommet.length;&nbsp;++i)&nbsp;{</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sommet&nbsp;s&nbsp;=&nbsp;sommet[i];</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if</tt><tt>&nbsp;(s.estEmploye())</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println&nbsp;(s);</tt><tt><br>
</tt><tt>&nbsp;&nbsp;&nbsp;&nbsp;}</tt><tt><br>
</tt><tt>&nbsp;&nbsp;}</tt></div><br>
<br>
<br>
La correction et l'optimisation des algorithmes de flots
dans les graphes sont étudiées dans le cours ``Conception des
Algorithmes et Optimisation`` de la majeure 2 d'Informatique.<br>
<br>
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<hr size="2">
<blockquote><em>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</em><a href="http://pauillac.inria.fr/%7Emaranget/hevea/index.html"><em>H<font size="2"><sup>E</sup></font>V<font size="2"><sup>E</sup></font>A</em></a><em>.
</em></blockquote>

</body></html>